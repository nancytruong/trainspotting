High-level Description
We decided to go with a stateless solution (so the train acts according to which sensors it passes). One of the first issues we realized is we needed some type of data structure to map from sensor coordinates to semaphores & switches. So we decided to make a hashtable with data types <Integer, SensorMapping). The Integer would be the sensor coordinate in one number (x * 100 + y ie (10, 07) -> 1007). The SensorMapping is our own class which holds 2 int arrays (acquireifToLower & acquireifToUpper). Each array contains the index of the sempahore to be acquired (depending on the direction of the train). We chose an array because you could have one or two possible semaphores to choose from. Since we do not always have to acquire a semaphore, we introduce two static variables: ACQUIRENOTHING & STOP. ACQUIRENOTHING is used when you pass a sensor that is directly after a switch. STOP is used when the train is approaching a station. Additionally we needed some type of mapping from sensor coordinate & next sempahore to switch coordinate & switch direction. We accomplished this with two methods (getSwitchDirection & getNextSwitch). These two methods used basic switch & if statements to accomplish their purpose. 

We implemented the majority of our solution in the class TrainThread. This class has the boolean variable toLower which indicates the direction the train is moving in (towards the lower station or not). It also contains the curSemaphore int which is the sempahore that is currently acquired. To help with determining which sempahores to release we also have the ints lastSemaphore & secondLastSemaphore. We have an infinite while loop that waits for the respective train's sensor events. By using getSensor() we avoid busy polling. From the sensor event, we extract the coordinates in order to get the list of next possible semaphores(nextSemaphores array). After getting the next possible semaphores, we have two courses of action. We can release or acquire a semaphore according the status & cooridnates of the sensor event. If the sensor event is INACTIVE and the int in the the nextSemaphores array is ACQUIRENOTHING, we know that the train has just exited a critical section and we can release a semaphore(lastSemaphore). If the train is currently on the intersection (sempahore with index 2) we keep the lastSemaphore acquired but if the lastSemaphore is 2 we release the second to last semaphore. If there is an active semaphore event, we have to check if we it is possible to acquire the next sempahore. If the int in nextSemaphores is STOP, that means the train has reached a station, so we set the speed to 0 and make the thread sleep for 1500ms. We also flip the direction (toLower) boolean and invert the speed. After the thread is finished sleeping, the train should continue on. However if the int in nexrSemaphores is a valid semaphore index, we try to acquire the specified semaphore. First we go through the array of possible semaphores (nextSemaphores) to try to acquire any of them. If this doesn't succeed, the thread is blocked (by using acquire() instead of tryAcquire()) until we can acquire the specified semaphore. If the thread has been blocked, we insure that the train has stopped until it can move again. Everytime we successfully acquire a semaphore, we check which switch is coming up & change the direction of the switch acoordingly.
 
Each continuous piece of track without a switch is a critical section. The only exception is the intersection in the upper left corner. This intersection is its own critical section. So in total we have 9 critical sections. We only release a critical section once the train is completely in the next section. 

We have placed a sensor two spaces away from each end of each critical section. We had to place each sensor two spaces away from the end of the critical section because that is the amount of space needed for the train to stop while it is going at maximum speed. Additionally we placed a sensor in front of every station so that we can know when the train needs to stop & wait.

Our maximum speed if 15. This is the maximum speed possible when the sensors are two spaces away from the end of the critical section because it needs at least 2 spaces to decelerate from speed 15 to 0.

To test our solution, we ran the program with different speed combinations. Here is a sample of the speeds we tested (speed of train 1, speed of train 2): (15,15), (15, 10), (15, 5), (5, 15), (5, 5), (10, 10), (15, 1), (10, 15), (15, 0). We also tried to get the trains to come to each switch at the same time to test if the semaphores are being acquired & released correctly (so we watched if the trains stopped to allow another train to pass). We also did this same sort of test with the intersection.  

    Placement of the sensors
    Choice of critical sections
    Maximum train speed and the reason for it
    How you tested your solution

