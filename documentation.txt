Data Structures
We decided to go with a stateless solution (so the train acts according to which sensors it passes). One of the first issues we realized is we needed some type of data structure to map from sensor coordinates to semaphores & switches. So we decided to make a hashtable with data types <Integer, SensorMapping>. The Integer would be the sensor coordinate in one number (x * 100 + y ie (10, 07) -> 1007). The SensorMapping is our own class which holds 2 int arrays (acquireifToLower & acquireifToUpper). Each array contains the indexes of the possible sempahores to be acquired (depending on the direction of the train). We chose an array because you could have one or two possible semaphores to choose from. Since we do not always have to acquire a semaphore, we introduce two static variables: ACQUIRENOTHING & STOP. ACQUIRENOTHING is used when you pass a sensor that is directly after a switch. STOP is used when the train is approaching a station. Additionally we needed some type of mapping from sensor coordinate & sempahore to switch coordinate & switch direction. We accomplished this with two methods (getSwitchDirection() & getNextSwitch()). These two methods used basic switch & if statements to accomplish their purpose.

Thread Details
We implemented the majority of our solution in the class TrainThread. This class has the boolean variable toLower which indicates the direction the train is moving in (towards the lower station or not). It also contains the currentSemaphore int which is the index of the sempahore that is currently acquired. To help with determining which sempahores to release we also have the ints lastSemaphore & secondLastSemaphore. We have an infinite while loop that waits for the respective train's sensor events. By using getSensor() we avoid busy polling. From the sensor event, we extract the coordinates in order to get the list of next possible semaphores (nextSemaphores). After getting the next possible semaphores, we have two courses of action. We can release or acquire a semaphore according the status & cooridnates of the sensor event. If there's an inactive sensor event and int in nextSempahore is ACQUIRENOTHING, we release the semaphore we just exited. An exception is the intersection in the upper left where we keep the last semaphore instead of releasing it. If there is an active semaphore event, we have to check if it is possible to acquire a semaphore by checking the int in nextSemaphores. First we go through the array of possible semaphores (nextSemaphores) to try to acquire any of them. If this doesn't succeed, the thread is blocked (by using acquire() instead of tryAcquire()) until we can acquire the specified semaphore. If the thread has been blocked, we insure that the train has stopped until it can move again. Everytime we successfully acquire a semaphore, we check which switch is coming up & change the direction of the switch acoordingly. If the int in nextSemaphores is STOP, that means the train has reached a station, so we set the speed to 0 and make the thread sleep for 1500ms. We also flip the direction (toLower) boolean and invert the speed. After the thread is finished sleeping, the train should continue on.
 
Critical Sections
Each continuous piece of track without a switch is a critical section. The only exception is the intersection in the upper left corner. This intersection is its own critical section. So in total we have 9 critical sections. We only release a critical section once the train is completely in the next section. 

Sensor Placements
We have placed a sensor two spaces away from each end of each critical section. We had to place each sensor two spaces away from the end of the critical section because that is the amount of space needed for the train to stop while it is going at maximum speed. Additionally we placed a sensor in front of every station so that we can know when the train needs to stop & wait.

Maximum Speed
Our maximum speed if 15. This is the maximum speed possible when the sensors are two spaces away from the end of the critical section because it needs at least 2 spaces to decelerate from speed 15 to 0.

Testing
To test our solution, we ran the program with different speed combinations. Here is a sample of the speeds we tested (speed of train 1, speed of train 2): (15,15), (15, 10), (15, 5), (5, 15), (5, 5), (10, 10), (15, 1), (10, 15), (15, 0). We also tried to get the trains to come to each switch at the same time to test if the semaphores are being acquired & released correctly (so we watched if the trains stopped to allow another train to pass). We also did this same sort of test with the intersection.
